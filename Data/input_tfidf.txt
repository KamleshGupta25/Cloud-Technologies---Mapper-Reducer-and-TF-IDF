4200	Under what circumstances - if any - does adding programmers to a team actually speed development of an already late project?
4300	I have two machines speed and mass. speed has a fast Internet connection and is running a crawler which downloads a lot of files to disk. mass has a lot of disk space. I want to move the files from speed to mass after they're done downloading. Ideally I'd just run:  $ rsync --remove-source-files speed:/var/crawldir .   but I worry that rsync will unlink a source file that hasn't finished downloading yet. (I looked at the source code and I didn't see anything protecting against this.) Any suggestions?
1935	I am trying to debate the point that version control is important for either one or two developers.    More specifically I work in a department in which there are typically two PHP developers using a shared framework.  He argues that there is no value added in us having Subversion installed on our development system whereas I argue that it is nice to occasionally be able to roll back to see previous code especially when there are unexplainable errors occurring that are hard to pin-point in some of the classes.    I think Subversion offers the easiest way to create and track changes for various reasons including debugging.  Would Subversion save any time?
45756	At Disney World they use a system called Fastpass to create a second shorter line for popular rides.  The idea is that you can wait in the standard line often with a wait longer than an hour or you can get a FastPass which allows you to come back during a specified time block (usually a couple hours later) and only wait for 10 minutes or less.  You can only be "waiting" for one ride at a time with a FastPass.  I have been trying to figure out the queue theory behind this concept but the only explanation I have found is that it is designed to get people out of the lines and doing things that will bring in additional revenue (shopping eating etc).    Is this why FastPass was implemented or is there a real visitor efficiency problem that it solving?  Are there software applications that have applied similar logic?  Are there software applications that should apply similar logic?  Part of the problem I see with implementing something similar in software is that it is based on users choosing their queue.  Do to the faster wait cycles in software I think a good application of this theory would require the application to be smart enough to know what queues to place people in based on their needs without requiring end-user choice.
33015	All code written in .NET languages compiles to MSIL but are there specific tasks / operations that you can do only using MSIL directly?  Let us also have things done easier in MSIL than C# VB.NET F# j# or any other .NET language.  So far we have this:   Tail recursion Generic Co/Contravariance Overloads which differ only in return types Override access modifiers Have a class which cannot inherit from System.Object Filtered exceptions (can be done in vb.net) Calling a virtual method of the current static class type. Get a handle on the boxed version of a value type. Do a try/fault. Usage of forbidden names. Define your own parameterless constructors for value types. Define events with a raise element. Some conversions allowed by the CLR but not by C#. Make a non main() method as the .entrypoint. work with the native int and native unsigned int types directly. Play with transient pointers emitbyte directive in  MethodBodyItem Throw and catch non System.Exception types Inherit Enums (Unverified) You can treat an array of bytes as a (4x smaller) array of ints. You can have a field/method/property/event all have the same name(Unverified). You can branch back into a try block from its own catch block. You have access to the famandassem access specifier (protected internal is famorassem) Direct access to the &lt;Module&gt; class for defining global functions or a module initializer.
686	I just got a question that I can't answer.  Suppose you have this loop definition in Java:  while (i == i) ;   What is the type of i and the value of i if the loop is not an infinite loop and the program is using only one thread?
1219	I really need to see some honest thoughtful debate on the merits of the currently accepted enterprise application design paradigm.  I am not convinced that entity objects should exist.  By entity objects I mean the typical things we tend to build for our applications like "Person" "Account" "Order" etc.  My current design philosophy is this:   All database access must be accomplished via stored procedures. Whenever you need data call a stored procedure and iterate over a SqlDataReader or the rows in a DataTable   (Note: I have also built enterprise applications with Java EE java folks please substitute the equvalent for my .NET examples)  I am not anti-OO.  I write lots of classes for different purposes just not entities.  I will admit that a large portion of the classes I write are static helper classes.  I am not building toys.  I'm talking about large high volume transactional applications deployed across multiple machines.  Web applications windows services web services b2b interaction you name it.  I have used OR Mappers.  I have written a few.  I have used the Java EE stack CSLA and a few other equivalents.  I have not only used them but actively developed and maintained these applications in production environments.  I have come to the battle-tested conclusion that entity objects are getting in our way and our lives would be so much easier without them.  Consider this simple example: you get a support call about a certain page in your application that is not working correctly maybe one of the fields is not being persisted like it should be.  With my model the developer assigned to find the problem opens exactly 3 files.  An ASPX an ASPX.CS and a SQL file with the stored procedure.  The problem which might be a missing parameter to the stored procedure call takes minutes to solve.  But with any entity model you will invariably fire up the debugger start stepping through code and you may end up with 15-20 files open in Visual Studio.  By the time you step down to the bottom of the stack you forgot where you started.  We can only keep so many things in our heads at one time.  Software is incredibly complex without adding any unnecessary layers.  Development complexity and troubleshooting are just one side of my gripe.  Now let's talk about scalability.  Do developers realize that each and every time they write or modify any code that interacts with the database they need to do a throrough analysis of the exact impact on the database?  And not just the development copy I mean a mimic of production so you can see that the additional column you now require for your object just invalidated the current query plan and a report that was running in 1 second will now take 2 minutes just because you added a single column to the select list?  And it turns out that the index you now require is so big that the DBA is going to have to modify the physical layout of your files?  If you let people get too far away from the physical data store with an abstraction they will create havoc with an application that needs to scale.  I am not a zealot.  I can be convinced if I am wrong and maybe I am since there is such a strong push towards Linq to Sql ADO.NET EF Hibernate Java EE etc.  Please think through your responses if I am missing something I really want to know what it is and why I should change my thinking.  [Edit]  It looks like this question is suddenly active again so now that we have the new comment feature I have commented directly on several answers.  Thanks for the replies I think this is a healthy discussion.  I probably should have been more clear that I am talking about enterprise applications.  I really can't comment on say a game that's running on someone's desktop or a mobile app.  One thing I have to put up here at the top in response to several similar answers: orthogonality and separation of concerns often get cited as reasons to go entity/ORM.  Stored procedures to me are the best example of separation of concerns that I can think of.  If you disallow all other access to the database other than via stored procedures you could in theory redesign your entire data model and not break any code so long as you maintained the inputs and outputs of the stored procedures.  They are a perfect example of programming by contract (just so long as you avoid "select *" and document the result sets).  Ask someone who's been in the industry for a long time and has worked with long-lived applications: how many application and UI layers have come and gone while a database has lived on?  How hard is it to tune and refactor a database when there are 4 or 5 different persistence layers generating SQL to get at the data?  You can't change anything!  ORMs or any code that generates SQL lock your database in stone.
79591	Start with these simple classes...  Let's say I have a simple set of classes like this:   class Bus {     Driver busDriver = new Driver(); }  class Driver {     Shoe[] shoes = { new Shoe() new Shoe() }; }  class Shoe {     Shoelace lace = new Shoelace(); }  class Shoelace {     bool tied = false; }   A Bus has a Driver the Driver has two Shoes each Shoe has a Shoelace. All very silly.    Add an IDisposable object to Shoelace  Later I decide that some operation on the Shoelace could be multi-threaded so I add an EventWaitHandle for the threads to communicate with. So Shoelace now looks like this:  class Shoelace {     private AutoResetEvent waitHandle = new AutoResetEvent(false);     bool tied = false;     // ... other stuff .. }   Implement IDisposable on Shoelace  But now Microsoft's FxCop will complain: "Implement IDisposable on 'Shoelace' because it creates members of the following IDisposable types: 'EventWaitHandle'."  Okay I implement IDisposable on Shoelace and my neat little class becomes this horrible mess:  class Shoelace : IDisposable {     private AutoResetEvent waitHandle = new AutoResetEvent(false);     bool tied = false;     private bool disposed = false;      public void Dispose()     {         Dispose(true);         GC.SuppressFinalize(this);     }      ~Shoelace()     {         Dispose(false);     }      protected virtual void Dispose(bool disposing)     {         if (!this.disposed)         {             if (disposing)             {                 if (waitHandle != null)                 {                     waitHandle.Close();                     waitHandle = null;                 }             }             // No unmanaged resources to release otherwise they'd go here.         }         disposed = true;     } }   Or (as pointed out by commenters) since Shoelace itself has no unmanaged resources I might use the simpler dispose implementation without needing the Dispose(bool) and Destructor:  class Shoelace : IDisposable {     private AutoResetEvent waitHandle = new AutoResetEvent(false);     bool tied = false;      public void Dispose()     {         if (waitHandle != null)         {             waitHandle.Close();             waitHandle = null;         }         GC.SuppressFinalize(this);     } }   Watch in horror as IDisposable spreads  Right that's that fixed. But now FxCop will complain that Shoe creates a Shoelace so Shoe must be IDisposable too.   And Driver creates Shoe so Driver must be IDisposable. And Bus creates Driver so Bus must be IDisposable and so on.  Suddenly my small change to Shoelace is causing me a lot of work and my boss is wondering why I need to checkout Bus to make a change to Shoelace.  The Question  How do you prevent this spread of IDisposable but still ensure that your unmanaged objects are properly disposed?
18402	Looking to do a very small quick 'n dirty side project. I like the fact that the Google App Engine is running on Python with Django built right in - gives me an excuse to try that platform... but my question is this:  Has anyone made use of the app engine for anything other than a toy problem? I see some good example apps out there so I would assume this is good enough for the real deal but wanted to get some feedback.  Any other success/failure notes would be great.
4228	Unit testing sounds great to me but I'm not sure I should spend any time really learning it unless I can convince others that is has significant value.  I have to convince the other programmers and more importantly the bean-counters in management that all the extra time spent learning the testing framework writing tests keeping them updated etc.. will pay for itself and then some.  What proof is there?  Has anyone actually developed the same software with two separate teams one using unit testing and the other not and compared the results?  I doubt it.  Am I just supposed to justify it with "Look it up on the Internet everybody's talking about it so it must be the right thing to do"?  Where is the hard evidence that will convince the laymen that unit testing is worth the effort?